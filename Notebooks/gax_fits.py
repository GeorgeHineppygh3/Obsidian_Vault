import os
import shutil
import jax
import numpy as np

from jax import numpy as jnp
from astropy.table import Table, vstack
from astropy.io import fits
import matplotlib.pyplot as plt
from scipy.ndimage import gaussian_filter
from scipy.interpolate import RegularGridInterpolator
from matplotlib.patches import Circle
from matplotlib.patches import Rectangle
from skimage.measure import shannon_entropy
from scipy.ndimage import rotate
from scipy.interpolate import RectBivariateSpline

bands = np.array(['u','g','r','i','z'])
wavs = np.array([3543.0, 4770.0, 6231.0, 7625.0, 9134.0], dtype=float) * 1e-10

def Write(image_data, filename):
    """
    Writes a 2D image data array to a FITS file.

    Args:
        image_data (NumPy array): A 2D numpy array representing the image data.
        filename (str): The name of the FITS file to write to.
    """
    # Create a new FITS HDU (Header-Data Unit) for the image data
    hdu = fits.PrimaryHDU(image_data)

    # Write the HDU to a new FITS file
    fits.writeto(filename, hdu.data, hdu.header, overwrite=True)

def Read_Table(Table_path):
    hdul = fits.open(Table_path)
    Astropy_Table = Table(hdul[1].data)
    return Astropy_Table

def Read(fits_path):
    """Function reads images from fits file from the file path

    Args:
        fits_path (string): file path to the fits file

    Returns:
        Jax NumPy array: 2D array of image
    """
    hdulist = fits.open(fits_path) # Open the FITS file

    data = hdulist[0].data # Get the data from the first HDU (header/data unit)

    return np.asarray(data) # Return JAX array of image



def Read_M_band(file_name,location):
    """Function reads multiple bands from a specified file location
    into stacked composite Jax NumPy array

    Args:
        file_name (string): string of file name
        location (string): string of path location 

    Returns:
        Composite: Composite array of all bands stacked vertically
    """
    # Find dimensions of image for creating empty composite array
    
    initial_fits_path = np.array(['{}{}ua.fits.gz'.format(location,file_name)])
    initial_image = Read(initial_fits_path[0])

    # Initialise composite array with dimensions of image and number of bands

    bands = np.array(['ua','ga','ra','ia','za'])
    Composite = np.empty((initial_image.shape[0],initial_image.shape[1],len(bands)))

    # Read images from folder into Composite array

    for i in range(0,len(bands)):
        fits_path = np.array(['{}{}{}.fits.gz'.format(location,file_name,bands[i])])
        #print(fits_path)
        image = Read(fits_path[0])
        Composite[:,:,i] = image

    # Return Composite JAX NumPy array

    return np.asarray(Composite)

def norm(X):
    return(X/np.max(X)) #normalise array

def Composite_imshow(Composite):
    """Plots each band of composite with title corresponding to band

    Args:
        Composite (NumPy array): Composite array of Images
    """
    fig, ax = plt.subplots(1,Composite.shape[2],figsize=(10,10))
    
    for i in range(0,Composite.shape[2]):
        ax[i].imshow(Composite[:,:,i])
        ax[i].set_title('{}'.format(bands[i]))
        ax[i].axis('off')

def multi_band_imshow(Composite_image,R_band,G_band,B_band):
    """Function creates an RGB image from a composite image array where
    bands can be specified for each channel but if not then:
    bands = np.array([u,g,r,i,z])
    R = bands[2] = r
    G = bands[1] = g
    B = bands[0] = u

    Args:
        Composite_image (array)): Composite array of all bands stacked vertically
        R_band (int): bands index for specified band
        G_band (int): bands index for specified band
        B_band (int): bands index for specified band
    """
    #if R_band is None and G_band is None and B_band is None:
     #   R_band = 2
      #  G_band = 1
       # B_band = 0

    R = norm(Composite_image[:,:,R_band]-np.average(Composite_image[0:20,0:20,R_band])) #Assign longest wavelength band to Red
    G = norm(Composite_image[:,:,G_band]-np.average(Composite_image[0:20,0:20,G_band])) #Assign middle wavelength band to Green
    B = norm(Composite_image[:,:,B_band]-np.average(Composite_image[0:20,0:20,B_band])) #Assign shortest wavelength band to Blue
    RGB = np.array([R,G,B]).T #Concatenate and transpose
    plt.figure()
    plt.axis('off')
    plt.imshow(RGB) #Show image

def R_e_bulge_mask(image,table,Bulge=False):
    """
    Generates a mask for a given image based on a table of parameters related to a bulge.

    The mask is generated by calculating the Euclidean distance between each pixel in the image and the position
    of the brightest pixel (assumed to be the center of the bulge) in the image. Pixels within a certain distance
    (determined by a factor of the effective radius, Re) from the bulge center are set to zero in the mask, while
    pixels outside this distance are set to one. The resulting masked image is obtained by element-wise multiplication
    of the original image with the generated mask.

    Args:
        image (numpy.ndarray): A 2D numpy array representing the input image.
        table (dict or structured array): A dictionary or structured array containing the parameters related to the
                                         bulge, including the effective radius (Re), which is used to determine
                                         the size of the mask.
        Bulge (boolean): whether to mask out the bulge

    Returns:
        numpy.ndarray: A masked version of the input image, where pixels within a certain distance from the center of
                       the bulge are set to zero and pixels outside this distance are preserved. The resulting masked
                       image has the same shape as the input image.
    """
    if Bulge:
        condition=np.array([1,0])
    else:
        condition=np.array([0,1])
    
    bulge_intensity = np.nanmax(image)
    if np.isnan(bulge_intensity):
        return np.nan
    else:
        bulge_pos = np.asarray(np.argwhere(image == bulge_intensity))
        #print(bulge_intensity,bulge_pos)
        Re = 10**table['log_re']
        multiple = 0.3
        Re_mask = np.empty((image.shape[0],image.shape[1]))
        for i in range(0,image.shape[0]):
            for j in range(0,image.shape[1]):
                if np.sqrt((j-bulge_pos[0,1])**2 + (i-bulge_pos[0,0])**2) < multiple*Re:
                    Re_mask[i,j] = condition[0]
                else:
                    Re_mask[i,j] = condition[1]

        return image*Re_mask

def threshold_image(image,value):
    mask = np.empty((image.shape[0],image.shape[1]))
    for i in range(0,image.shape[0]):
        for j in range(0,image.shape[1]):
            if image[i,j] > value:
                mask[i,j] = 0
            else:
                mask[i,j] = 1
    return mask

def gaussian_psf(image,stddev,size,smooth):
    """Function creates a guassian psf for an image

    Args:
        image (2D array): image that psf is being generated for
        stddev (float): standard deviation fo gaussian kernel
        size (int): size fo kernel central intensity in pixels
        smooth (Bool): Boolean for whether psf is smoothed or not before returning

    Returns:
        psf: Gaussian psf same size as input function with specified size and std dev
    """
    # Create the 2D Gaussian kernel
    x, y = np.meshgrid(np.linspace(-size/2, size/2, size), np.linspace(-size/2, size/2, size))
    kernel = np.exp(-(x**2 + y**2) / (2*stddev**2))
    # Normalise kernel
    kernel /= np.sum(kernel)
    # Create array size of imageS
    psf = np.zeros(image.shape)
    # Place kernel at the center of array
    center = (np.array(image.shape) - 1) / 2 
    xmin = int(center[0] - (size - 1) / 2)
    xmax = int(center[0] + (size - 1) / 2) + 1
    ymin = int(center[1] - (size - 1) / 2)
    ymax = int(center[1] + (size - 1) / 2) + 1
    
    psf[xmin:xmax, ymin:ymax] = kernel
    
    if smooth == True:
        psf = gaussian_filter(psf,sigma=stddev)
        return psf
    else:
        return psf

def create_folder(location,folder_name):
    os.makedirs(os.path.join(location, folder_name))    

# Now combine into a funtion:
import os
import shutil

 
            
def Generate_config(filename,location,config_path,output_path):
    """Generate a config file from a given filename and location, and write it to a .yml file.

    Parameters:
        filename (str): The name of the file to generate the config file for.
        location (str): The location of the file to generate the config file for.
        config_ptah (str): The directory to write the config files to.
        output_path (str): The parent directory to write the ficl output files to.

    Returns:
        None
    """
    # First get current working so we can return to after
    current = os.getcwd()
    # specify the name of the directory you want to move the config files to
    destination_dir = config_path
    
    # Move to output directory
    os.chdir(destination_dir)
    
    # Remove file information from filename
    file = filename.removesuffix('.fits.gz')

    # Create a basic string of the config file
    document = """image_filename = loc_/filename_
    #psf_filename = None
    output_path = _output_/file_
    psf_oversampling = 1
    sb_threshold = 0
    source_flux_limit = 0
    max_source_count = 1
    learning-rate = 0.05
    large_threshold = 50
    large_nsamples = 25
    large_scale_nonpar_rate = 0
    small_scale_nonpar_rate = 0.05
    max_iterations = 200
    warmup = 3
    modeller = gax
    gax_integration_order = 3
    save_iteration_frequency = 100
    loglevel = DEBUG
    nsigma = 1.0
    background = 5098
    smooth_sigma = 51.0
    smooth_size = 151.0
    detect_npixels = 1000
    deblend_npixels = 1000
    deblend_nlevels = 16
    deblend_contrast = 0.5
    """
    # Replace basic componenents with specified variables
    doc1 = document.replace('loc_',str(location),1)
    doc2 = doc1.replace('filename_',str(filename),1)
    doc3 = doc2.replace('file_',str(file),1)
    doc4 = doc3.replace('_output_',output_path,1)
    
    # specify the name of your output file
    output_file = 'file__config.txt'
    output_file = output_file.replace('file_',file,1)

    # open the file for writing and write the string to the file
    with open(output_file, 'w') as file:
        file.write(doc4)
        
    # specify the name of the file you want to rename
    old_filename = output_file

    # get the filename without the extension
    base = os.path.splitext(old_filename)[0]

    # specify the new filename with the .yml extension
    new_filename = base + '.yml'

    # rename the file
    os.rename(old_filename, new_filename)
    
    
    # move back to original chdir
    os.chdir(current)
    
    print('config_file_created: {} in {}'.format(new_filename,destination_dir)) 
    return new_filename 

def Generate_config_M_band(name,input_path,output_path):
    """Function creates config files for all bands from an image file name.

    Args:
        name (str): filename
        input_path (str): path to file creating config for
        output_path (str): path to config output location
    """
    band_suffix = np.array(['ua.fits.gz','ga.fits.gz','ra.fits.gz','ia.fits.gz','za.fits.gz'],dtype=str)
    filenames = np.empty(len(bands)).astype(str)

    for i in range(0,len(filenames)):
       filenames[i] = str(name + band_suffix[i])
    
    for i in range(0,len(filenames)):
        Generate_config(filenames[i],input_path,output_path)
    
    
    
def centroid(img,cartesian):
    """First moment of the flux distribution.

    Parameters
    ----------
    img : numpy or jax array

    Returns
    -------
    x, y : floats
        The calculated centroid position.
    """
    x_cen = (np.arange(img.shape[0]) * img.sum(1) / img.sum()).sum()
    y_cen = (np.arange(img.shape[1]) * img.sum(0) / img.sum()).sum()
    
    if cartesian == True:
        return x_cen, y_cen
    else:
        return y_cen, x_cen # array indices are swapped
    
    
def command_line_file_list_run(file_list,data_location,config_path,output_path):
    """
    Generates and runs FICL commands for a list of FITS files.

    Args:
    - file_list: a list of FITS file names.
    - data_location: the directory where the FITS files are located.
    - output_path: the directory where the ficl outputs will be created

    Returns:
    None
    """    
    # Get directory to return to 
    current = os.getcwd()

    # Create list of filenames without file information
    files = np.empty_like(file_list).astype(str)
    for i in range(0,len(file_list)):
        files[i] = file_list[i].removesuffix('.fits')


    # Generate output folders:
    for i in range(0,len(file_list)):
        create_folder(output_path,files[i])
            
    # Generate the config files:
    config_list = []
    for i in range(0,len(file_list)):
        config_element = Generate_config(file_list[i],data_location,config_path,output_path)
        config_list.append(config_element)

    # first navigate to outer ficl directrory
    os.chdir('/home/borge/ficl/')

    # Initialise list of commands for running
    commands = []

    command_structure = 'python -m ficl.main -c '


    # Write commands to array
    for i in range(0,len(file_list)):
        command_element = command_structure + config_path + '/' + config_list[i]
        commands.append(command_element)


    # Loop through the list of commands and run each one using os.system
    for i in range(0,len(commands)):
        os.system(commands[i])

    # move back to original cwdir
    os.chdir(current)

def command_line_file_list_server_run(file_list,data_location,config_path,output_path):
    """
    Generates and runs FICL commands for a list of FITS files.

    Args:
    - file_list: a list of FITS file names.
    - data_location: the directory where the FITS files are located.
    - output_path: the directory where the ficl outputs will be created

    Returns:
    None
    """    
    # Get directory to return to 
    current = os.getcwd()

    # Create list of filenames without file information
    files = np.empty_like(file_list).astype(str)
    for i in range(0,len(file_list)):
        files[i] = file_list[i].removesuffix('.fits.gz')


    # Generate output folders:
    for i in range(0,len(file_list)):
        create_folder(output_path,files[i])
            
    # Generate the config files:
    config_list = []
    for i in range(0,len(file_list)):
        config_element = Generate_config(file_list[i],data_location,config_path,output_path)
        config_list.append(config_element)

    # first navigate to outer ficl directrory
    os.chdir('/home/ppygh3/ficl/')

    # Initialise list of commands for running
    commands = []

    
    command_structure = 'XLA_PYTHON_CLIENT_PREALLOCATE=false nohup python -m ficl.main -c /home/ppygh3/Data/Config_Files/'
    command_ending = ' &> ficl.out &'

    # Write commands to array
    for i in range(0,len(file_list)):
        command_element = command_structure + config_list[i] + command_ending
        commands.append(command_element)


    # Loop through the list of commands and run each one using os.system
    for i in range(0,len(commands)):
        os.system(commands[i])

    # move back to original cwdir
    os.chdir(current)


# Old function that tried to count the background to remove the over 1 problem

def flux_frac(Composite,Composite_isolated):
    """
    Calculates the flux fraction between a composite image and an isolated composite image for each band.

    Args:
    - Composite (np.ndarray): A 3D numpy array of the composite image.
    - Composite_isolated (np.ndarray): A 3D numpy array of the isolated composite image.

    Returns:
    - flux_fraction (np.ndarray): A 1D numpy array containing the flux fraction for each band.
    """
    # Need to modify this so that it takes away the pixels exactly equal to 1000 and not 1000 from pixels 
    background_value = 1000.0
    counters = np.empty_like(wavs)#.astype(int)
    for s in range(0,len(bands)):
        for i in range(0,Composite[:,:,s].shape[0]):
            for j in range(0,Composite[:,:,s].shape[1]):
                if Composite[i,j,s] == background_value:
                    #Composite[i,j,s] = 0
                    counters[s] += background_value
                else:
                    continue
                
    
    flux_fraction = np.empty_like(wavs).astype(float)

    for s in range(0,len(bands)):
        flux_fraction[s] = np.sum(Composite_isolated[:,:,s])/(np.sum(Composite[:,:,s]))#-(counters[s])) # *background_value
    print(counters)
    print(flux_fraction)
    return flux_fraction


# Current function as this makes the most logical sense and includes the bulge masking

def flux_fraction(Image,Table,Original_Image,Bulge):
    
    if np.isnan(np.any(Image)):
        print('Found a Nan')
        return np.nan
    else:
        # First apply the bulge mask to the FICL process image
        masked_Image = R_e_bulge_mask(Image,Table,Bulge=Bulge)
        
        # Set background for SDSS images
        background = 1000
        
        # Calculate fraction of flux in the masked to original image
        flux_fraction  = np.sum(masked_Image)/np.sum(Original_Image-background)
        
        return flux_fraction

def remove_file_info(filename):
    n = len('.fits.gz')
    file = filename[:-n]
    return file

def remove_band_info(filename):
    n = len('ra.fits.gz')
    file = filename[:-n]
    return file

def raid_directory(directory_path):
    """
    Navigates to the most recent subdirectory within a given directory path and reads in two FITS files.

    Parameters:
    -----------
    directory_path : str
        A string representing the path of the directory to search for subdirectories.

    Returns:
    --------
    Tuple
        A tuple of two FITS file objects, `source_params_table` and `small_non_par_image`.

    Raises:
    -------
    FileNotFoundError:
        If no subdirectories are found within the given directory.
    TypeError:
        If the directory path provided is not a string.

    Note:
    -----
    This function assumes that the subdirectories within the given directory have integer names and that the most recent subdirectory has the highest integer value name. Additionally, it assumes that the FITS files `source_params.fits` and `small_nonpar.fits` exist within the most recent subdirectory.
    """
    # get current working directory to return to at the end
    current = os.getcwd()
    
    # Move to folder 
    os.chdir(directory_path)

    # List directory contents
    contents = os.listdir()
    # convert to an array
    arr = np.asarray(contents).astype(int)

    # Find contents largest output value
    latest = np.max(arr)

    # Convert back to string     (we assume no iterations over 1000)
    if latest > 100:
        latest = '0' + str(latest)
    else:
        latest = '00' + str(latest)

    # Move to most recent output directory
    os.chdir(latest)

    # Read files in
    source_params_table = Read_Table('source_params.fits')
    small_non_par_image = Read('small_nonpar.fits')
    
    # Return to original directory
    os.chdir(current)
    return(source_params_table,small_non_par_image)

def Composite_from_directory_raid(OBJID,Parent_directory):
    """
    Create a composite image and source parameter table by raiding multiple directories.

    Parameters
    ----------
    OBJID : str
        The object ID used to create directory names.
    Parent_directory : str
        The parent directory where the OBJID subdirectories are located.

    Returns
    -------
    Composite_Source_Table : astropy.table.Table
        A table containing the composite source parameters.
    Isolated_Composite : numpy.ndarray
        A 3D array containing the isolated composite image data.

    Notes
    -----
    The function expects the OBJID subdirectories to have the following suffixes:
    'ua', 'ga', 'ra', 'ia', 'za', corresponding to the five filter bands used in the imaging survey.
    The function first raids the directory for the first filter band to get the image dimensions,
    and then reads in the non-parametric images from the other bands to create the isolated composite.
    The source parameter tables from all bands are stacked together to create the composite source parameter table.
    Finally, the composite source parameter table is augmented with additional columns indicating the filter band and
    the corresponding effective wavelength.
    """
    # Create suffix array for raiding
    bands_suffix = np.array(['ua','ga','ra','ia','za'])

    # Initialise list of directories to raid
    directrories_to_raid = []

    # creates a list of directories based on the OBJID    
    #directrories_to_raid
    for i in range(0,len(bands)):
        directory = Parent_directory + OBJID + bands_suffix[i]
        directrories_to_raid.append(directory)
         
    # First raid directory to get image dimensions for Composite
    source0, nonpar0 = raid_directory(directrories_to_raid[0])
    Composite_Source_array = source0[0]
    Isolated_Composite = np.empty((nonpar0.shape[0],nonpar0.shape[1],len(bands)))
    Isolated_Composite[:,:,0] = nonpar0

    # Raid the rest of the directories
    for i in range(1,len(bands)):
        source_table, non_par = raid_directory(directrories_to_raid[i])
        Isolated_Composite[:,:,i] = non_par
        Composite_Source_array = np.vstack([Composite_Source_array,source_table[0]])
    
    # Convert array to astropy table
    Composite_Source_Table = Table(Composite_Source_array)
    
    # Now want to add a column detailing band and corresponding central wavelength
    Composite_Source_Table.add_column(bands, name='Band')
    Composite_Source_Table.add_column(wavs,name='Effective Wavelength')
        
    return Composite_Source_Table, Isolated_Composite

# From http://rb.gy/s3ijjr and very fast!
def gini(array):
    """Calculate the Gini coefficient of a numpy array."""
    # based on bottom eq: http://www.statsdirect.com/help/content/image/stat0206_wmf.gif
    # from: http://www.statsdirect.com/help/default.htm#nonparametric_methods/gini.htm
    array = array.flatten() #all values are treated equally, arrays must be 1d
    if np.amin(array) < 0:
        array -= np.amin(array) #values cannot be negative
    array += 0.0000001 #values cannot be 0
    array = np.sort(array) #values must be sorted
    index = np.arange(1,array.shape[0]+1) #index per array element
    n = array.shape[0]#number of array elements
    return ((np.sum((2 * index - n  - 1) * array)) / (n * np.sum(array))) #Gini coefficient


def gen_spiral(p_max,A_p_m,m,R_e,R_min_multiple,img,x0,y0):
    """
    Generates a polar spiral with the given parameters and returns its x and y coordinates.

    Args:
        p_max (float): The maximum power density of the spiral.
        A_p_m (numpy.ndarray): Array of complex amplitudes of the spiral.
        m (float): Constant that determines the rate of increase in pitch of the spiral.
        R_e (float): The radius of the spiral.
        R_min_multiple (float): Multiple of R_e that represents the minimum radius at which the spiral can be sampled.

    Returns:
        tuple: A tuple of two numpy arrays representing the x and y coordinates of the polar spiral.
    """
    # Get image info:
    height, width = img.shape[:2]   
    
    # Create Polar Spiral
    A_p_max = A_p_m[np.argmax(A_p_m)]
    argument = np.angle(A_p_max)
    r_0 = 1                                     # Scale 1:1 pix
    theta = np.linspace(2*np.pi,8*(np.pi),3600)
    phi = np.degrees(np.arctan((0-m)/p_max))
    r = r_0 *np.exp(theta*np.abs(np.tan(np.radians(phi)))) 
    
    # Convert to Cartesian
    x = r*np.cos(theta)
    y = r*np.sin(theta) 
    vector = np.stack([x,y],axis=1).T
    
    rot_mat = np.array([[np.cos(argument),-np.sin(argument)],
                    [np.sin(argument), np.cos(argument)]])

    rotated_vector = rot_mat @ vector

    x_ = rotated_vector[0] 
    y_ = rotated_vector[1] 
    
   # Trim line plot so that it doesn't enter the unsampled area or outside the image
    count_c = 0
    count_e = 0 
    for i in range(0,len(x_)):
        if np.sqrt(x_[i]**2 + (y_[i]**2)) <= R_min_multiple*R_e:
            count_c = count_c +  1
        elif  np.sqrt(x_[i]**2 + (y_[i]**2)) > min(x0, y0, width-x0, height-y0):
            count_e = count_e + 1
        else:
            continue
    x_ = x_[count_c:len(x_)-count_e]
    y_ = y_[count_c:len(y_)-count_e]

    #print(x0.shape,x0[0])
    #x0 = np.asarray(x0)
    #y0 = np.asarray(y0)
    #print(x0.shape,x0[0])
    #print(x0,x0.shape)
    #return x_+ x0[0], y_ + y0[0], argument
    if isinstance(x0, np.ndarray):
        return x_+ x0[0], y_ + y0[0], argument
    else:
        return x_+ x0, y_ + y0, argument

   
def SN(A):
    """This function calculates the signal to noise for the global maxima as well as a weighting list for each component

    Args:
        A (numpy array): A complex array representing the spiral fourier transform of an image

    Returns:
        SN_max (float): Signal to noise on the global maxima
        SN_weightings (numpy array): Signal to noise for each p
    """
    # get average of power spectrum
    L = np.average(np.abs(A))
    # Calculate rms estimate of the spectrum
    sigma = np.sqrt(np.average((np.abs(A)-L)**2))

    # Calculate signal to noise of global maxima using sigma and L
    SN_max = (np.abs(A[np.argmax(np.abs(A))])-L)/sigma 
    
    # Calculate signal to noise of all values to provide a weighting list
    SN_weightings = (np.abs(A)-L)/sigma 
    
    return SN_max, SN_weightings


def Spiral_Fourier_Transform(Image,Table,R_min_multiple,m,plot,save,byte_order=False):
    """A function to calculate the Spiral Fourier Transform and the winding angle of a given image.

    Args:
    Image (numpy.ndarray): A 2D numpy array representing the input image.
    Table (astropy.Table): A table containing the coordinates and parameters of the object to be analyzed.
    R_min_multiple (float): The multiple of the effective radius at which the minimum radius is set.
    m (int): The order of the Fourier mode.
    plot (bool): A boolean indicating whether or not to plot the results.
    save (bool): A boolean indicating whether or not to save the plot.

    Returns:
    phi (float): The winding angle in degrees.
    """
    
    img = Image
    Tab = Table
    # First collect image info from Table
    x0 = np.array([img.shape[1]/2 + np.asarray(Tab['x'])]).astype(int) # x offset
    print(x0.shape,x0[0])
    y0 = np.array([img.shape[0]/2 + np.asarray(Tab['y'])]).astype(int) # y offset
    R_e = 10**(np.asarray(Tab['log_re'])) # effective radius in pix
    log_R_e = np.asarray(Tab['log_re']) # log effective radius
    log_R_e_05 = np.log(10**np.asarray(Tab['log_re'])*R_min_multiple) # log half effective radius
    pa = np.asarray(Tab['theta']) # position angle
    q = np.asarray(Tab['q']) # axis ratio
    
    
    # Get the dimensions of the Image
    height, width = img.shape[:2]   

    # Calculate the maximum possible radius
    max_radius = min(x0, y0, width-x0, height-y0)
    max_R = max_radius -1
    
    # Create x and y index arrays
    y, x = np.indices(img.shape)
    
    # Center index arrays
    x -= x0
    y -= y0
    
    # Deprojecting x,y by a series of affine transformations

    # Rotate by minus position angle
    ct = np.cos(-pa)
    st = np.sin(-pa)

    # Stretch according to axis ratio and rotation
    xp = (y * ct + x * st) / q
    yp = (-y * st + x * ct)

    # Convert to Polar
    rp2 = xp ** 2 +  yp ** 2
    rp = np.sqrt(rp2)
    tp = np.arctan2(yp, xp)
    
    # Define ln(r),theta image dimensions
    n_lnr = 150
    n_theta = 150
    
    # Create index arrays
    lnr, theta = np.indices((n_lnr, n_theta))
    
    # Define bounds for image dimensions
    lnr_min = float(log_R_e_05)
    lnr_max = float(np.log(int(max_R) -1))
    theta_max = 360
    lnr = (lnr / n_lnr) * (lnr_max - lnr_min) + lnr_min
    theta = theta * theta_max / n_theta
    
    # Create yticks arrays
    lnr_y_axis = np.linspace(lnr_min,lnr_max,5)
    
    # Define xp and yp in terms of new coord system
    xp = np.exp(lnr) * np.sin(np.radians(theta))
    yp = np.exp(lnr) * np.cos(np.radians(theta))
    
    # this is an attempt at using the above deprojection code
    # to do the inverse by pa -> -pa and q -> 1/q   
    ct = np.cos(pa)
    st = np.sin(pa)
    x = (yp * ct + xp * st) * q
    y = (-yp * st + xp * ct)
    x += y0
    y += x0
    
    if byte_order == True:
        img = img.byteswap().newbyteorder('L')
    else:
        img = img
    
    # Create a Regular grid from interpolation
    img_interp = RegularGridInterpolator((np.arange(img.shape[0]),
                                          np.arange(img.shape[1])),img, bounds_error=False)
    
    # Define allowed indices
    ok = (x >= 0) & (x < img.shape[0] - 1) 
    ok &= (y >= 0) & (y < img.shape[1] - 1) 
    
    # Create image from interpolation
    img_lnr_theta = img_interp((x, y))
    
    # Use broadcasting to do multiple p at once
    p = np.arange(-25, 25, 0.1).reshape((-1, 1, 1))
    weight = np.exp(1j*(m * np.radians(theta) + lnr * p))
    D = img_lnr_theta.sum()
    A = 1/D * abs((img_lnr_theta * weight).sum((-1, -2)))
    A_p_m = 1/D *(img_lnr_theta * weight).sum((-1, -2))
    
    # Calculate winding angle from maximum of Spiral Power spectrum
    p_max = p.ravel()[A.argmax()]
    phi = np.degrees(np.arctan((0-m)/p_max))#
    
    print(x0.shape,x0[0])
    # Generate spiral for plotting
    x_,y_, argument = gen_spiral(p_max,A_p_m,m,R_e,R_min_multiple,img,x0[0],y0[0])
    
    if 88<phi<92 or -88>phi>-92:
        print('Winding angle \u03C6 =',None,'- No pattern identified')
    else:
        print('Winding angle \u03C6 =', phi,' Pattern position angle \u03B8 = ',np.degrees(argument))
        
    
    
    # Calculate signal to Noise
    SN_m, SN_w = SN(A_p_m)

    if plot == True:
        
        # Spiral Power Spectrum
        plt.figure()
        plt.plot(p.ravel(), A,'k')
        plt.vlines(p_max,0,np.max(A),'k','dashed','$p_(max)$')
        plt.legend(['Spiral Power Spectrum ','$p_{max}$'],loc='upper left')
        plt.title('Spiral Power Spectrum (m = {}, SNR = {})'.format(m,np.around(SN_m,1)))
        plt.xlabel('p')
        plt.xticks([-20,-10,p_max,0,10,20],['-20','-10','{}'.format(np.around(p_max,1)),'0','10','20'])
        plt.ylabel('|A(p,m)|');
        if save == True:
            plt.savefig('Power Spectrum.png')
        
        # ln(r) theta imageS
        plt.figure()
        plt.imshow(img_lnr_theta.T,vmin=1000,vmax=1200, extent=(lnr_min, lnr_max, 0, theta_max), #, vmin=np.mean(img_lnr_theta)-2*np.std(img_lnr_theta), vmax=np.mean(img_lnr_theta)+2*np.std(img_lnr_theta),
           origin='lower', aspect='auto');
        plt.ylabel('\u03B8')
        #plt.xticks([0,int(theta_max/4),int(theta_max/2),int(((theta_max)*3)/4),theta_max],['0','\u03C0/2','\u03C0','3\u03C0/2','2\u03C0'])  # come back
        plt.xlabel('log(R)')
        plt.yticks([0,int(img.shape[0]/4),int(img.shape[0]/2),int(((img.shape[0])*3)/4),img.shape[0]],['0','\u03C0/2','\u03C0','3\u03C0/2','2\u03C0'])
        if save == True:
            plt.savefig('log(R) Theta image.png')
        
        # Labeled galaxy Image
        fig, ax = plt.subplots()
        ax.imshow(img,vmin=1000,vmax=1200)#,vmin=np.mean(img)-2*np.std(img),vmax=np.mean(img)+2*np.std(img))

        # Define circle
        R_e_1 = Circle((x0,y0),R_e,edgecolor='black', facecolor=None, fill=False)
        R_e_05 = Circle((x0,y0),R_min_multiple*R_e,edgecolor='red', facecolor=None, fill=False)
        
        ax.plot(x0,y0,'xk')
        ax.plot(x_,y_,'r-')
        
        ax.add_patch(R_e_1)
        ax.add_patch(R_e_05)
        ax.legend(['center','Spiral Fit','$R_e$','${}\, R_e$'.format(R_min_multiple)])
        ax.axis('off')
        if save == True:
            plt.savefig('Labelled R_e image.png')
        
        return phi, argument
    
    else:
        return phi, argument
 

def Spiral_power_spec(Image,Table,R_min_multiple,m,byte_order=False):
    """
    This function calculates the Spiral Power Spectrum of an input image based on a given table of galaxy properties.

    Parameters:
    Image (numpy array): Input image to be analyzed
    Table (astropy Table): Table containing galaxy properties including x, y, log_re, theta, and q
    R_min_multiple (float): Multiplicative factor for the effective radius to set the minimum radius for the Spiral Power Spectrum
    m (int): Integer value for the number of spiral arms to analyze

    Returns:
    A (numpy array): Spiral Power Spectrum values
    p (numpy array): Fourier mode values
    SN_w (numpy array): the signal to noise wights for each A(p,m)
    p_max (float): Fourier mode corresponding to the maximum Spiral Power Spectrum value
    SN_m (float): Signal to noise of the global maxima
    phi (float): Winding angle of the spiral arms in degrees
    """
    img = Image
    Tab = Table
    # First collect image info from Table
    x0 = np.array([img.shape[1]/2 + np.asarray(Tab['x'])]).astype(int) # x offset
    y0 = np.array([img.shape[0]/2 + np.asarray(Tab['y'])]).astype(int) # y offset
    R_e = 10**(np.asarray(Tab['log_re'])) # effective radius in pix
    log_R_e = np.asarray(Tab['log_re']) # log effective radius
    log_R_e_05 = np.log(10**np.asarray(Tab['log_re'])*R_min_multiple) # log half effective radius
    pa = np.asarray(Tab['theta']) # position angle
    q = np.asarray(Tab['q']) # axis ratio
    
    
    # Get the dimensions of the Image
    height, width = img.shape[:2]   

    # Calculate the maximum possible radius
    max_radius = min(x0, y0, width-x0, height-y0)
    max_R = max_radius -1
    
    # Create x and y index arrays
    y, x = np.indices(img.shape)
    
    # Center index arrays
    x -= x0
    y -= y0
    
    # Deprojecting x,y by a series of affine transformations

    # Rotate by minus position angle
    ct = np.cos(-pa)
    st = np.sin(-pa)

    # Stretch according to axis ratio and rotation
    xp = (y * ct + x * st) / q
    yp = (-y * st + x * ct)

    # Convert to Polar
    rp2 = xp ** 2 +  yp ** 2
    rp = np.sqrt(rp2)
    tp = np.arctan2(yp, xp)
    
    # Define ln(r),theta image dimensions
    n_lnr = 150
    n_theta = 150
    
    # Create index arrays
    lnr, theta = np.indices((n_lnr, n_theta))
    
    # Define bounds for image dimensions
    lnr_min = float(log_R_e_05)
    lnr_max = float(np.log(int(max_R) -1))
    theta_max = 360
    lnr = (lnr / n_lnr) * (lnr_max - lnr_min) + lnr_min
    theta = theta * theta_max / n_theta
    
    # Define xp and yp in terms of new coord system
    xp = np.exp(lnr) * np.sin(np.radians(theta))
    yp = np.exp(lnr) * np.cos(np.radians(theta))
    
    # this is an attempt at using the above deprojection code
    # to do the inverse by pa -> -pa and q -> 1/q   
    ct = np.cos(pa)
    st = np.sin(pa)
    x = (yp * ct + xp * st) * q
    y = (-yp * st + xp * ct)
    x += y0
    y += x0
    
    if byte_order == True:
        img = img.byteswap().newbyteorder('L')
    else:
        img = img
    
    # Create a Regular grid from interpolation
    img_interp = RegularGridInterpolator((np.arange(img.shape[0]),
                                          np.arange(img.shape[1])), img)
    
    # Define allowed indices
    ok = (x >= 0) & (x < img.shape[0] - 1) 
    ok &= (y >= 0) & (y < img.shape[1] - 1) 
    
    # Create image from interpolation
    img_lnr_theta = img_interp((x, y))
    
    # Use broadcasting to do multiple p at once
    p = np.arange(-25, 25, 0.1).reshape((-1, 1, 1))
    weight = np.exp(1j*(m * np.radians(theta) + lnr * p))
    D = img_lnr_theta.sum()
    A = 1/D * abs((img_lnr_theta * weight).sum((-1, -2)))
    A_p_m = 1/D *(img_lnr_theta * weight).sum((-1, -2))
    # Calculate winding angle from maximum of Spiral Power spectrum
    p_max = p.ravel()[A.argmax()]
    phi = np.degrees(np.arctan((0-m)/p_max))
    #print('Winding angle \u03C6 =', phi)
    
    # Calculate signal to noise 
    SN_m, SN_w = SN(A)
    
    return A, A_p_m, p, SN_w, p_max, SN_m, phi 

def Number_of_arms(Image,Table,R_e_multiple,plot,save,objid=None,byte_order=False):
    """
    This function calculates the number of spiral arms in an image by analyzing its power spectrum.

    Parameters:

    Image: a 2D numpy array representing the image.
    Table: a dictionary containing the logarithmic spiral model parameters (see Spiral_power_spec function).
    R_e_multiple: the value of the effective radius to be used for the logarithmic spiral model.
    Returns:

    An integer representing the estimated number of spiral arms in the image.
    """
    # Create Fourier order array
    NAm = np.arange(0,5,1) + 1
    A_arr = np.empty((500,len(NAm))) # len(A)=500
    labels = ['u','g','r','i','z'] # These are in Table['Band'] but I don't get them out correctly
    colors = ['Blue','Green','Red','Purple','Orange']
        
    # Initialise empty arrays
    m_arr = np.empty_like(NAm).astype(float)
    p_max_arr = np.empty_like(m_arr)
    
    # Sort Byte order
    if byte_order == True:
        Image = Image.byteswap().newbyteorder('L')
    else:
        Image = Image

    # Create Loop for each band
    for i in range(0,len(NAm)):
        A, A_p_m, p, SN_w, p_max, SN_m, phi = Spiral_power_spec(Image,Table,R_e_multiple,NAm[i])
        m_arr[i] = np.max(A)
        A_arr[:,i] = A
        p_max_arr[i] = p_max
        
    #print(m_arr,np.argmax(m_arr))
        
    if plot == True:
        # Spiral Power Spectrum
        plt.figure()
        #plt.title('Spiral Power Spectrum for {}'.format(objid,NAm,np.around(SN_m,1)))
        plt.xlabel('p')
        plt.ylabel('|A(p,m)|')
        plt.xticks([-20,-10,p_max_arr[np.argmax(m_arr)],0,10,20],['-20','-10','{}'.format(np.around(p_max_arr[np.argmax(m_arr)],1)),'0','10','20'])
        
        for i in range(0,len(m_arr)):
            if i != np.argmax(m_arr):
                dash_dom = '--'
            else:
                dash_dom = None
                colors[i] = 'k'
            plt.plot(p.ravel(),A_arr[:,i],color=colors[i],linestyle=dash_dom)
        
        plt.vlines(p_max_arr[np.argmax(m_arr)],0,np.max(A_arr[:,1]),'k','dashed','$p_{max}$',linewidth=2.5)
        plt.legend(['m = {}'.format(NAm[0]),'m = {}'.format(NAm[1]),'m = {}'.format(NAm[2]),'m = {}'.format(NAm[3]),'m = {}'.format(NAm[4]),'$p_{max}$'])
        #plt.legend(['Band {}'.format(labels[0]),'Band {}'.format(labels[1]),'Band {}'.format(labels[2]),'Band {}'.format(labels[3]),'Band {}'.format(labels[4])])
        
        if save == True:
            plt.savefig('Power Spectrum all m.png')
    
    return NAm[np.argmax(m_arr)]

def save_spiral_power_spec(OBJID, band, band_index, A, A_p_m, p, SN_w, p_max, SN_m, phi, argument):
    """This function assembles the outputs of Spiral_power_spec() function into a FITS table and saves it to disk

    Args:
        OBJID (str): ID of the object
        band (str): Name of the band
        band_index (int): Index of the band
        A (numpy array): Complex array representing the spiral Fourier transform of an image
        p (numpy array): Array of radial frequencies
        SN_w (numpy array): Signal-to-noise ratio for each radial frequency
        p_max (float): Radial frequency of the global maximum
        SN_m (float): Signal-to-noise ratio at the global maximum
        phi (float): Phase of the complex value at the global maximum
        argument (float) : The position angle of the dominant pattern

    Returns:
        (str): Filename of the saved FITS file
    """
    # Create FITS table
    hdu = fits.BinTableHDU.from_columns([
        fits.Column(name='abs(A)', format='D', array=A.real),
        fits.Column(name='A_real', format='D', array=A_p_m.real),
        fits.Column(name='A_imag', format='D', array=A_p_m.imag),
        fits.Column(name='p', format='D', array=p),
        fits.Column(name='SN_w', format='D', array=SN_w),
        fits.Column(name='p_max', format='D', array=[p_max]),
        fits.Column(name='SN_m', format='D', array=[SN_m]),
        fits.Column(name='phi', format='D', array=[phi]),
        fits.Column(name='phi', format='D', array=[np.degrees(argument)])
    ])

    # Add header information
    hdu.header['OBJID'] = OBJID
    hdu.header['BAND'] = band
    hdu.header['BANDINDX'] = band_index

    # Save FITS file
    filename = f'{OBJID}_{band}_{band_index}.fits'
    hdu.writeto(filename, overwrite=True)

    return filename, hdu

def cat_search(catalogue,OBJID):
    
    if len(catalogue['OBJID_STR'][0]) > 18:
        OBJID_STR_array = np.asarray(catalogue['OBJID_STR'])
        
        trimmed_OBJID_STR_array = []
        for s in OBJID_STR_array:
            new_s = s[:-2]
            trimmed_OBJID_STR_array.append(new_s)
        
        trimmed_OBJID_STR_array = np.asarray(trimmed_OBJID_STR_array)
        
        mask = trimmed_OBJID_STR_array == OBJID
    else:
        mask = catalogue['OBJID_STR'] == OBJID
        
    
    row = Table(catalogue[mask])
    return row

def collect_candidate_info(candidate_list, catalogue, requests=None):
    """
    Collects information from a catalogue for a list of candidates.
    
    Args:
    candidate_list (array-like): A list of candidate objects to search for in the catalogue.
    catalogue (astropy.table.Table): A table object containing the catalogue data.
    
    Returns:
    tuple: A tuple containing the following arrays:
        U_mags (numpy.ndarray): Array of U magnitudes for each candidate.
        R_mags (numpy.ndarray): Array of R magnitudes for each candidate.
        U_mag_errs (numpy.ndarray): Array of U magnitude errors for each candidate.
        R_mag_errs (numpy.ndarray): Array of R magnitude errors for each candidate.
        dists (numpy.ndarray): Array of comoving distances for each candidate.
        zs (numpy.ndarray): Array of redshifts for each candidate.
        zerrs (numpy.ndarray): Array of redshift errors for each candidate.
        colours (numpy.ndarray): Array of U-R colours for each candidate.
        colour_errs (numpy.ndarray): Array of errors in U-R colour for each candidate.
    """
    U_mags = np.empty_like(candidate_list, dtype=float)
    R_mags = np.empty_like(candidate_list, dtype=float)
    U_mag_errs = np.empty_like(candidate_list, dtype=float)
    R_mag_errs = np.empty_like(candidate_list, dtype=float)
    dists = np.empty_like(candidate_list, dtype=float)
    zs = np.empty_like(candidate_list, dtype=float)
    zerrs = np.empty_like(candidate_list, dtype=float)
    colours = np.empty_like(candidate_list, dtype=float)
    colour_errs = np.empty_like(candidate_list, dtype=float)
    
    
    
    for i in range(0,len(candidate_list)):
        tab = cat_search(catalogue, candidate_list[i])
        #print(tab,tab['U'],tab['R'])
        U_mags[i] = float(tab['U'])
        R_mags[i] = float(tab['R'])
        U_mag_errs[i] = float(tab['UERR'])
        R_mag_errs[i] = float(tab['UERR'])
        dists[i] = float(tab['COMOVING_DISTANCE'])
        zs[i] = float(tab['REDSHIFT'])
        zerrs[i] = float(tab['REDSHIFTERR'])
        colours[i] = float(U_mags[i] - R_mags[i])
        colour_errs[i] = float(np.sqrt(U_mag_errs[i]**2 + R_mag_errs[i]**2))
        
            
        
    return U_mags, R_mags, U_mag_errs, R_mag_errs, dists, zs, zerrs, colours, colour_errs  


def var_from_dir_raid(candidates,parent_dir):
    
    # Create array of identifiers:
    identifiers = np.asarray([s[-4:] for s in candidates])
    identifiers.astype(str)
    
    comp_ = 'comp_'
    tab_ = 'tab_'
    
    # Assign all the candidates information from the directory raid to variables
    for i in range(0,len(identifiers)):
        exec('{}{}, {}{} = gfits.Composite_from_directory_raid("{}","{}")'
             .format(tab_,identifiers[i],comp_,identifiers[i],candidates[i],parent_dir))
        
    # Create a list of variable names created
    comps_array = np.empty_like(candidates)
    tabs_array = np.empty_like(candidates)

    for i in range(0,len(candidates)):
        comps_array[i] = '{}{}'.format(comp_,identifiers[i])
        tabs_array[i] = '{}{}'.format(tab_,identifiers[i])
        
    return comps_array, tabs_array, identifiers
        
    
def get_variable_from_name(name):
    # Create a list of all the defined variables
    var_dict = globals() 
    
    # Get the variables from the list
    var_value = var_dict.get(name)
    
    return var_value        

def line_equation(point1, point2):
    """
    Given two points, return the equation of the line that passes through them
    in slope-intercept form: y = mx + b
    """
    x1, y1 = point1
    x2, y2 = point2

    # Calculate the slope (m)
    m = (y2 - y1) / (x2 - x1)

    # Calculate the y-intercept (b)
    c = y1 - m * x1

    # Return the equation of the line in slope-intercept form
    return m, c

def normal_to_line(m, c, point):
    """
    Given the slope (m), y-intercept (c), and a point a line passes through,
    return the slope and y-intercept of the line that is normal (perpendicular) to it and passes through the point.
    """
    # Calculate the negative reciprocal of the slope to get the slope of the normal line
    m_normal = -1 / m

    # Calculate the y-intercept of the normal line using the point it passes through
    x, y = point
    b_normal = y - m_normal * x

    # Return the slope and y-intercept of the normal line
    return m_normal, b_normal


def normal_from_points(x0,y0,x1,y1):
    """
    Calculates the normal vector of a line passing through two points.

    Args:
        x0 (float): The x-coordinate of the first point.
        y0 (float): The y-coordinate of the first point.
        x1 (float): The x-coordinate of the second point.
        y1 (float): The y-coordinate of the second point.

    Returns:
        Tuple[float, float]: A tuple containing the slope and y-intercept of the normal line
        to the line passing through (x0, y0) and (x1, y1). The normal line passes through the
        midpoint of the line segment connecting (x0, y0) and (x1, y1).

    Raises:
        ZeroDivisionError: If the line passing through (x0, y0) and (x1, y1) is vertical.
    """
    middle = (x0+((x1-x0)/2),y0+((y1-y0)/2))
    m,c= line_equation((x0,y0),(x1,y1))
    m_n, m_c = normal_to_line(m,c,middle)
    return m_n, m_c

def get_pixels_on_line(normal_intersect, m, c,pixels): #passed in the coordinates of the spiral-lin-line intercept
    #returns 'result' which is an array of pixel co-ordinates
    resulf=np.empty((2*pixels,2))
    if (abs(m)<1): #count along the X-axis as it's not steep
        n=0
        for my_x in range(normal_intersect[0]-pixels,normal_intersect[0]+pixels):
            resulf[n]=(my_x,m*my_x+c)
            n=n+1
        #resulf = np.flip(resulf,axis=0)
    else: #this is steep, so work in the y dimension
        n=0
        for my_y in range (normal_intersect[1]-pixels,normal_intersect[1]+pixels):
            resulf[n]=(((my_y-c)/m),my_y)
            n=n+1
        #resulf = np.flip(resulf,axis=0)
    result=resulf.astype(int)
    return result

def get_normals(spiral_points,num_samples):
    """
    Computes the normal lines to a spiral at specified sample points.

    Args:
        spiral_points (numpy.ndarray): A 2D numpy array containing the (x, y) coordinates of
            points along the spiral curve.
        num_samples (int): The number of sample points to use for computing the normal lines.

    Returns:
        Tuple[numpy.ndarray, numpy.ndarray, numpy.ndarray]: A tuple containing three numpy
        arrays: the slope and y-intercept of the normal lines at each sample point, and the
        (x, y) coordinates of the sample points.

    """
    samples = np.linspace(0,len(spiral_points)-1,num_samples,dtype=int)
    tangent_points = spiral_points[samples]
 
    bigger_r  = samples+1
    smaller_r = samples-1

    for i in range(0,len(bigger_r)):
        if bigger_r[i] >= len(spiral_points):
            bigger_r[i] = len(spiral_points)-1
        else:
            continue

    big_point   = spiral_points[bigger_r]
    small_point = spiral_points[smaller_r]

    m_array = np.zeros(len(big_point)) # Because you look up one and down one and so need to trim both ends
    c_array = np.zeros(len(big_point))

    for i in range(1,len(big_point)): # Don't calculate the 0th or last point OOR
        m_array[i-1], c_array[i-1] = normal_from_points(small_point[i,0],small_point[i,1],big_point[i,0],big_point[i,1]) 
        
    return m_array, c_array, tangent_points


def Spiral_normal_distributions(image,table,spiral_points,num_samples,
                                half_line_width,plot,analysis,spiral_points2=None):
    """
    Computes normal distributions along a spiral arm in an astronomical image.

    Parameters:
    -----------
    image : numpy.ndarray
        The input astronomical image.
    table : astropy.table.table.Table
        A table containing galaxy properties.
    spiral_points : numpy.ndarray
        An array of points on the spiral arm.
    num_samples : int
        Number of samples to be taken along the spiral arm.
    half_line_width : int
        Half-width of the line in pixels.
    plot : bool
        Whether or not to plot the output.
    analysis : bool
        Whether or not to perform an analysis on the plotted output.
    
    kwargs*:
    --------
    spiral_points2: numpy.ndarray
        An array of points on the other spiral arm.
        
    Notes:
    ------
    spiral_points2 as a kwarg* allows for the function to run on one or two arms with a default of one.
    The Resulting plots show both overlays and then each normal sampled image in two labeled subplots.

    Returns:
    --------
    numpy.ndarray
        A transposed array of stacked pixel values representing the normal distributions.
    """ 
    # Get equations of normal lines using above function
    sp_m_array, sp_c_array, tangent_points = get_normals(spiral_points,num_samples)
        
    # Calculate distance of each tangent point in terms of R_e
    # First collect centers and R_e from table
    x0 = table['x'] + image.shape[1]/2
    y0 = table['y'] + image.shape[0]/2
    R_e = 10**(table['log_re'])
    
    # Loop through tangent points and calculate radius at each point
    radii_in_pixels = np.empty(len(tangent_points))
    for i in range(0,len(tangent_points)):
        radii_in_pixels[i] =  np.sqrt((x0-tangent_points[i,0])**2+(y0-tangent_points[i,1])**2)
    
    # Get tangent_points in terms of R_e
    radii_in_R_e = radii_in_pixels/R_e
    
    # Sample radii array to get y_ticks
    y_tick_samples = np.linspace(0,len(radii_in_R_e)-1,5).astype(int)
    y_ticks = radii_in_R_e[y_tick_samples]
    y_tick_labels = np.array(['{}'.format(np.around(y_ticks[0],2)),
                              '{}'.format(np.around(y_ticks[1],2)),
                              '{}'.format(np.around(y_ticks[2],2)),
                              '{}'.format(np.around(y_ticks[3],2)),
                              '{}'.format(np.around(y_ticks[4],2))])
    
    # Set up Params for x_ticks
    quarter_line_width = half_line_width/2
    line_width = half_line_width*2

    # Stack sampled pixels into image
    stacked_line_pixels = np.zeros((line_width,len(tangent_points)))
    
    for j in range(1,len(tangent_points)):
        
        array = get_pixels_on_line(tangent_points[j].astype(int),sp_m_array[j],sp_c_array[j],half_line_width)
        
        
        line_pixel_values = np.empty(len(array))
        
        for i in range(0,array.shape[0]):
            if array[i,0] >= image.shape[0] or array[i,1] >= image.shape[1]:
                line_pixel_values[i] = 0
            else:
                line_pixel_values[i] = image[array[i,0],array[i,1]] #assumes image is (x,y)
        
        # Not a Botch - sorts the flipping problem due to gradients tending to np.inf
        if sp_m_array[j] > 1:
            stacked_line_pixels[:,j] = line_pixel_values[::-1]
        elif sp_m_array[j] < -1:
            stacked_line_pixels[:,j] = line_pixel_values[::-1]
        #elif sp_m_array[j] > 0 and m_array[j] > 1:
        #    stacked_line_pixels[:,j] = line_pixel_values[::-1]
        #elif sp_m_array[j] > 0:
        #    stacked_line_pixels[:,j] = line_pixel_values[::-1]
        else:
            stacked_line_pixels[:,j] = line_pixel_values
        
    stacked_line_pixels = stacked_line_pixels.T
    
    
    if spiral_points2 is not None:
        sp_m_array2, sp_c_array2, tangent_points2 = get_normals(spiral_points2, num_samples)

        stacked_line_pixels2 = np.zeros((line_width, len(tangent_points2)))

        for j in range(1, len(tangent_points2)):
            array = get_pixels_on_line(tangent_points2[j].astype(int), sp_m_array2[j], sp_c_array2[j], half_line_width)
            line_pixel_values = np.empty(len(array))
            for i in range(0, array.shape[0]):
                if array[i,0] >= image.shape[0] or array[i,1] >= image.shape[1]:
                    line_pixel_values[i] = 0
                else:
                    line_pixel_values[i] = image[array[i,0],array[i,1]]
            
            # Not a Botch - sorts the flipping problem due to gradients tending to np.inf
            if sp_m_array2[j] < -1:
                stacked_line_pixels2[:,j] = line_pixel_values[::-1]
            elif sp_m_array2[j] > 0:
                stacked_line_pixels2[:,j] = line_pixel_values[::-1]
            else:
                stacked_line_pixels2[:,j] = line_pixel_values

        stacked_line_pixels2 = stacked_line_pixels2.T
    
    # Plotting section
    
    if plot == True:
        colours =  plt.cm.plasma(np.linspace(0,1,len(tangent_points)))
        
        plt.figure()
        vmin, vmax = np.percentile(image, (0.5, 99.5))
        plt.imshow(image,vmin=vmin,vmax=vmax)
        plt.plot(spiral_points[:,0],spiral_points[:,1],'r')
        plt.xlim(0,image.shape[1])
        plt.ylim(0,image.shape[0])
        plt.axis('off')
       
        for i in range(1,len(tangent_points)):
            arr = get_pixels_on_line(tangent_points[i].astype(int),sp_m_array[i],sp_c_array[i],int(half_line_width/4)) #waS 20
            arr = np.asarray(arr).astype(int)
            #plt.plot(tangent_points[i,0],tangent_points[i,1],'kx') ##see where it is
            if analysis == True:
                if i%10 == 0: #show the normals for every 10th sample
                    plt.plot(arr[:,0],arr[:,1],c='k')
                else:
                    continue
                    
            else:
                plt.plot(arr[:,0],arr[:,1],c=colours[i])
                
        if spiral_points2 is not None:
            plt.plot(spiral_points2[:,0],spiral_points2[:,1],'r')
            
            for i in range(1,len(tangent_points2)):
                arr2 = get_pixels_on_line(tangent_points2[i].astype(int),sp_m_array2[i],sp_c_array2[i],int(half_line_width/4)) #was 20
                arr3 = np.asarray(arr2).astype(int)
                
                if analysis == True:
                    if i%10 == 0: #show the normals for every 10th sample
                        plt.plot(arr3[:,0],arr3[:,1],c='k')
                    else:
                        continue   
                else:
                    plt.plot(arr3[:,0],arr3[:,1],c=colours[i])
        
        plt.gca().invert_yaxis()

        if spiral_points2 is not None:
            # Create a figure with two subplots side by side
            fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))

            # Set title and plot for Spiral Arm 1
            ax1.set_title('Arm 1')
            ax1.imshow(np.flip(stacked_line_pixels,axis=1), aspect='auto', origin='lower') 
            ax1.set_xticks([0, half_line_width/2, half_line_width, half_line_width*1.5, line_width-1],
                        ['-{}'.format(half_line_width), '-{}'.format(int(quarter_line_width)), '0',
                            '{}'.format(int(quarter_line_width)), '{}'.format(half_line_width)])
            ax1.set_yticks(y_tick_samples, y_tick_labels)
            ax1.set_xlabel('Distance from Spiral fit (pixels)')
            ax1.set_ylabel('Radial Distance/ $R_e$ ')
            
            if analysis == True:
                ax1.hlines(np.arange(0, len(tangent_points2), 10), 0, stacked_line_pixels2.shape[1]-1, colors='k')
            plt.gca().invert_xaxis()

            # Set title and plot for Spiral Arm 2
            ax2.set_title('Arm 2')
            ax2.imshow(stacked_line_pixels2, aspect='auto', origin='lower') 
            ax2.set_xticks([0, half_line_width/2, half_line_width, half_line_width*1.5, line_width-1],
                        ['-{}'.format(half_line_width), '-{}'.format(int(quarter_line_width)), '0',
                            '{}'.format(int(quarter_line_width)), '{}'.format(half_line_width)])
            ax2.set_yticks(y_tick_samples, y_tick_labels)
            
            ax2.set_xlabel('Distance from Spiral fit (pixels)')
            ax2.set_ylabel('Radial Distance/ $R_e$ ')
            if analysis == True:
                ax2.hlines(np.arange(0, len(tangent_points2), 10), 0, stacked_line_pixels2.shape[1]-1, colors='k')
            #plt.gca().invert_xaxis()
            
        else:   
            plt.figure()
            minI,maxI=np.percentile(stacked_line_pixels,(0.5,99.5))
            plt.imshow(stacked_line_pixels,vmin=minI,vmax=maxI,aspect='auto',origin='lower') # This is quite amazing! #,vmin=1000,vmax=1100
            plt.xticks([0,half_line_width/2,half_line_width,half_line_width*1.5,line_width-1],
                    ['-{}'.format(half_line_width),'-{}'.format(int(quarter_line_width)),'0',
                        '{}'.format(int(quarter_line_width)),'{}'.format(half_line_width)])
            plt.yticks(y_tick_samples,y_tick_labels)
            plt.xlabel('Distance from Spiral fit (pixels)')
            plt.ylabel('Radial Distance/ $R_e$ ')
            if analysis == True:
                plt.hlines(np.arange(0,len(tangent_points),10),0,stacked_line_pixels.shape[1]-1,colors='k')
    
    return stacked_line_pixels
        
        
def deproject_galaxy_image(image, center, position_angle, axis_ratio):
    """
    Deprojects a galaxy image based on position angle, axis ratio, and center coordinates.

    Args:
        image (ndarray): Input galaxy image.
        center (tuple): Center coordinates (x, y) of the galaxy in the image.
        position_angle (float): Position angle (in degrees) of the galaxy.
        axis_ratio (float): Axis ratio of the galaxy.

    Returns:
        ndarray: Deprojected galaxy image.
    """
    # Convert position angle to radians
    theta = np.deg2rad(position_angle)

    # Shift the galaxy center to the origin
    x, y = center
    image_centered = np.roll(np.roll(image, -y+image.shape[0]//2, axis=0), -x+image.shape[1]//2, axis=1)

    # Create a grid of coordinates centered at the origin
    xx, yy = np.meshgrid(np.arange(-image.shape[1]//2, image.shape[1]//2), np.arange(-image.shape[0]//2, image.shape[0]//2))

    # Rotate the grid by the position angle
    xx_rot = xx * np.cos(theta) + yy * np.sin(theta)
    yy_rot = -xx * np.sin(theta) + yy * np.cos(theta)

    # Scale the rotated grid by the axis ratio
    xx_scaled = xx_rot / axis_ratio
    yy_scaled = yy_rot * axis_ratio

    # Interpolate the deprojected image from the scaled grid to the original grid
    deprojected_image = RectBivariateSpline(yy_scaled[:, 0], xx_scaled[0, :], image_centered)(yy[:, 0], xx[0, :])

    return deprojected_image

def CAS(image,table):
    
    """
    Calculates Concentration (C), Asymmetry (A), and Smoothness (S) parameters for a galaxy image.

    The CAS parameters are commonly used in astronomy to quantify the morphological properties of galaxies.
    This function takes an input galaxy image and a table of parameters containing information about the galaxy,
    such as center coordinates, position angle, axis ratio, and effective radius. It then calculates the Concentration,
    Asymmetry, and Smoothness parameters based on the provided algorithm.

    Args:
        image (ndarray): Galaxy image for which the CAS parameters need to be calculated.
        table (Table): Table of parameters containing information about the galaxy.

    Returns:
        tuple: A tuple containing the calculated Concentration (C), Asymmetry (A), and Smoothness (S) parameters.

    Note:
        This function assumes that the deproject_galaxy_image() function is available to deproject the galaxy image.
        The deproject_galaxy_image() function should be called before calling this function to deproject the galaxy image.

    References:
        - Conselice, C. J. 2003, ApJS, 147, 1
        - Lotz, J. M., et al. 2004, ApJ, 613, 262
        - Bershady, M. A., et al. 2000, AJ, 119, 2645
    """
    
    # Create some logic to return nan if nans present in table
    
    img = image
    Tab = table
    table_array = np.array([Tab['x'],Tab['y'],Tab['theta'],Tab['q'],Tab['log_re'],Tab['log_n']])
    #print(table_array)
    
    if np.isnan(table_array).any():
        C = np.nan 
        A = np.nan
        S = np.nan
        #print('Nan Found')
        return C,A,S
    else:
        C = 0.0
        A = 0.0
        S = 0.0
    
    # Gather Information
    centre = (int(img.shape[1]/2 + np.asarray(Tab['x'])),int(img.shape[0]/2 + np.asarray(Tab['y'])))
    pa = float(Tab['theta'])
    q = float(Tab['q'])
    

    # 'approximations commonly used in astronomy' - estimating R20 and R80 form R50

    Re = 10**Tab['log_re']
    R20 = 0.4*Re
    R80 = 1.4*Re

    # Deproject image
    
    dep_im = deproject_galaxy_image(img,centre,pa,q)

    # Create Concentration masks
    
    R20_mask = np.empty_like(img)
    R80_mask = np.empty_like(img)
    for i in range(0,img.shape[0]):
        for j in range(0,img.shape[1]):
            if np.sqrt((i-centre[1])**2+(j-centre[0])**2) < R20:
                R20_mask[i,j] = 1
            else:
                R20_mask[i,j] = 0
        
            if np.sqrt((i-centre[1])**2+(j-centre[0])**2) < R80:
                R80_mask[i,j] = 1
            else:
                R80_mask[i,j] = 0

    R20_img = dep_im*R20_mask
    R80_img = dep_im*R80_mask

    # Rotate image 180 for Asymmetry
    
    rotated_im = np.rot90(dep_im,2)
    
    # Normalise dep_im for shannon_entropy for 

    norm_dep_im = dep_im/np.max(dep_im)

    high_freq_structures = shannon_entropy(norm_dep_im)
    total_flux = np.sum(norm_dep_im)

    # Calculate CAS parameters
    C = 5*np.log10(np.sum(R80_img)/np.sum(R20_img))
    A = np.sum(np.abs(dep_im-rotated_im))/np.sum(dep_im)
    S = high_freq_structures/total_flux
    
    return C,A,S

def Overlay_table_info(Image,Table,inner_multiple,outer_multiple,R_e_on=True):
    """
    Overlay a circle and two rings over an image at the position and size specified by a table.

    Parameters
    ----------
    Image : ndarray
        A 2D array representing the image to be plotted.
    Table : dict
        A dictionary containing the table information with keys 'x', 'y', and 'log_re'.
        'x' and 'y' represent the position of the galaxy in pixels, and 'log_re' represents
        the logarithm of the effective radius of the galaxy in units of pixels.
    inner_multiple : float
        A positive number specifying the radius multiplier for the inner ring with respect to R_e.
    outer_multiple : float
        A positive number specifying the radius multiplier for the outer ring with respect to R_e.

    Returns
    -------
    None
        This function displays the plot but does not return anything.

    Notes
    -----
    The function overlays a circle patch representing the galaxy's effective radius,
    and two ring patches (inner and outer) centered on the same position as the circle patch,
    with radii specified as multiples of the effective radius. The function also plots the
    image with a red 'x' marker indicating the center of the galaxy.
    """
    
    # Get table information
    x_centre = Image.shape[1]/2 + Table['x']
    y_centre = Image.shape[0]/2 + Table['y']
    R_e      = 10**Table['log_re']
    
    # Create the Circle patch using table information
    R_e_patch = plt.Circle((x_centre,y_centre),R_e,fill=None)
    inner_multiple_patch = plt.Circle((x_centre,y_centre),R_e*inner_multiple,fill=None,color='r',linestyle='--')
    outer_multiple_patch = plt.Circle((x_centre,y_centre),R_e*outer_multiple,fill=None,color='r',linestyle='--')
    
    # Begin plotting
    fig, ax = plt.subplots()
    vmin, vmax = np.percentile(Image, (0.5, 99.5))
    ax.imshow(Image,vmin=vmin,vmax=vmax)
    ax.plot(x_centre,y_centre,'rx')
    if R_e_on:
        ax.add_patch(R_e_patch)
        ax.add_patch(inner_multiple_patch)
        ax.add_patch(outer_multiple_patch)
    else:
        ax.add_patch(inner_multiple_patch)
        ax.add_patch(outer_multiple_patch)
    
    
def pitch_angle_against_radius(Image,Table,N=1,Split=70):
    """
    Calculates pitch angles against inner radii for a given image and table data.

    Parameters:
        Image (array): The input image for which pitch angles need to be calculated.
        Table (array): The input table data associated with the image.
        N (float): The effective radius multiple that the Inner_radii_multiples array runs to.
        Split (integer): The number of samples of Inner_radii
    Returns:
        Inner_radii_multiples (array): An array of inner radii multiples ranging from 0.3 to 1 with 70 equally spaced values.
        phi_array (array): An array of pitch angles, where each element represents the pitch angle at a specific combination of inner radii multiple and dominant harmonic mode. The shape of phi_array is (len(Inner_radii_multiples), len(m_array)).
    """
   
    # Need to create an array of inner radii
    Inner_radii_multiples = np.linspace(0.3,N,Split)

    # Create array of dominant harmonic modes
    m_array = np.arange(0,6,1)+1

    # Create an empty array of pitch angles 
    phi_array = np.empty((len(Inner_radii_multiples),len(m_array)))
    A_p_max_array = np.empty((len(Inner_radii_multiples),len(m_array)))

    for j in range(0,phi_array.shape[1]):
        for i in range(0,phi_array.shape[0]):
            A, A_p_m, p, SN_w, p_max, SN_m, phi_array[i,j] = Spiral_power_spec(Image,Table,Inner_radii_multiples[i],m_array[j],byte_order=False)
            A_p_max_array[i,j] = np.max(A) 

    # Calculate relative power
    Relative_A_p_max_array = np.empty_like(A_p_max_array)
    for i in range(0,len(A_p_max_array)):
        Relative_A_p_max_array[i,:] = A_p_max_array[i,:]/np.sum(A_p_max_array[i,:])

    return Inner_radii_multiples, phi_array, Relative_A_p_max_array
    
def plot_radial_pitch_angle_dependance(Candidate,phi_array,Inner_radii_multiples):
    """
    Plots the radial dependence of pitch angles for a given candidate.

    Parameters:
        Candidate (str): The name or identifier of the candidate for which the plot is being generated.
        phi_array (array): An array of pitch angles, where each element represents the pitch angle at a specific combination of inner radii multiple and dominant harmonic mode. The shape of phi_array is (len(Inner_radii_multiples), len(m_array)).
        Inner_radii_multiples (array): An array of inner radii multiples ranging from 0.3 to 1 with 70 equally spaced values.

    Returns:
        Plot: A plot showing the radial dependence of pitch angles for different harmonic modes, with the average winding angle for m=2 harmonic mode indicated in the plot title. The plot has pitch angle values on the y-axis, inner radii multiples on the x-axis, and different harmonic modes represented by different line styles/colors. The plot also includes a legend with labels for each harmonic mode. The y-axis is limited to a range of -90 to 90 degrees.
    """    
    M_str_arr = np.array(['m = 1','m = 2','m = 3','m = 4','m = 5','m = 6'])
    plt.figure()
    avg_pitch = np.around(np.mean(phi_array[:,1]),1)
    plt.title('{} Average winding angle (m=2): {}\u00B0'.format(Candidate,avg_pitch))
    plt.ylabel('Pitch angle (deg)')
    plt.xlabel('Inner Radius / $R_e$')
    for i in range(0,len(M_str_arr)):
        if i == 1:
            plt.plot(Inner_radii_multiples,phi_array[:,i],c='k')
        else:
            plt.plot(Inner_radii_multiples,phi_array[:,i],linestyle='--')
        
        
    plt.ylim(-90,90)    
    plt.legend(M_str_arr)
    
def plot_pitch_angle_relative_power(Candidate,phi_array,Inner_radii_multiples,relative_power):
    M_str_arr = np.array(['m = 1','m = 2','m = 3','m = 4','m = 5','m = 6'])

    # create a figure with two subplots
    fig, axs = plt.subplots(1, 2, figsize=(10, 4))
    #print ("Plot: phi_array=\n",phi_array.shape, phi_array)
    # plot the first subplot
    avg_pitch = np.around(np.mean(phi_array[:,1]),1)
    fig.suptitle('{} Average winding angle (m=2): {}\u00B0'.format(Candidate,avg_pitch))
    axs[0].set_ylabel('Pitch angle (deg)')
    axs[0].set_xlabel('Inner Radius / $R_e$')
    for i in range(0,len(M_str_arr)):
        if i == 1:
            axs[0].plot(Inner_radii_multiples,phi_array[:,i],c='k')
        else:
            axs[0].plot(Inner_radii_multiples,phi_array[:,i],linestyle='--')   
    axs[0].set_ylim(-90,90)    
    axs[0].legend(M_str_arr)

    # plot the second subplot
    axs[1].set_xlabel('Inner Radius/$R_e$')
    axs[1].set_ylabel('Relative Power')
    for i in range(0,relative_power.shape[1]):
        if i == 1:
            axs[1].plot(Inner_radii_multiples,relative_power[:,i],c='k')
        else:
            axs[1].plot(Inner_radii_multiples,relative_power[:,i],linestyle='--')
        
    axs[1].legend(M_str_arr)

    # adjust layout and spacing
    plt.tight_layout()